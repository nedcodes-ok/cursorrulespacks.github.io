#!/usr/bin/env node
/**
 * sync-playground.js
 * Extracts lint rules, patterns, and thresholds from cursor-doctor/src/index.js
 * and regenerates the <script> section in playground.html.
 *
 * Run: node scripts/sync-playground.js
 * Requires: ../cursor-doctor/src/index.js exists
 */

const fs = require('fs');
const path = require('path');

const DOCTOR_SRC = path.resolve(__dirname, '../../cursor-doctor/src/index.js');
const PLAYGROUND = path.resolve(__dirname, '../playground.html');

if (!fs.existsSync(DOCTOR_SRC)) {
  console.error('ERROR: cursor-doctor source not found at', DOCTOR_SRC);
  process.exit(1);
}

const src = fs.readFileSync(DOCTOR_SRC, 'utf-8');

// --- Extract constants from index.js ---

function extractArray(source, varName) {
  // Match: const VARNAME = [\n  'item',\n  ...\n];
  const re = new RegExp(`(?:const|var)\\s+${varName}\\s*=\\s*\\[([\\s\\S]*?)\\];`);
  const m = source.match(re);
  if (!m) return null;
  const items = [];
  const itemRe = /['"]([^'"]+)['"]/g;
  let im;
  while ((im = itemRe.exec(m[1]))) items.push(im[1]);
  return items;
}

function extractConflictPairs(source) {
  // Match conflict pair objects: { a: '...', b: '...', subject: '...' }
  const pairs = [];
  const re = /\{\s*a:\s*'([^']+)',\s*b:\s*'([^']+)',\s*subject:\s*'([^']+)'\s*\}/g;
  let m;
  while ((m = re.exec(source))) {
    pairs.push({ a: m[1], b: m[2], subject: m[3] });
  }
  return pairs;
}

function extractValidKeys(source) {
  const m = source.match(/const\s+validKeys\s*=\s*\[([^\]]+)\]/);
  if (!m) return ['description', 'globs', 'alwaysApply'];
  const keys = [];
  const re = /['"]([^'"]+)['"]/g;
  let km;
  while ((km = re.exec(m[1]))) keys.push(km[1]);
  return keys;
}

function extractVagueQualifiers(source) {
  // Extract the "after" context words from findVagueRules
  const qualifiers = [];
  const re = /after\.startsWith\('(\w+ )'\)/g;
  let m;
  while ((m = re.exec(source))) qualifiers.push(m[1].trim());
  return [...new Set(qualifiers)];
}

function extractImperativeVerbs(source) {
  // Extract from the imperativeVerbs regex
  const m = source.match(/imperativeVerbs\s*=\s*\/\\b\(([^)]+)\)\\b/);
  if (!m) return null;
  return m[1].split('|');
}

// --- Extract values ---

const vaguePatterns = extractArray(src, 'VAGUE_PATTERNS');
const conflictPairs = extractConflictPairs(src);
const validKeys = extractValidKeys(src);
const qualifiers = extractVagueQualifiers(src);
const imperativeVerbs = extractImperativeVerbs(src);

if (!vaguePatterns) {
  console.error('ERROR: Could not extract VAGUE_PATTERNS from index.js');
  process.exit(1);
}

console.log(`Extracted from cursor-doctor/src/index.js:`);
console.log(`  VAGUE_PATTERNS: ${vaguePatterns.length} patterns`);
console.log(`  Conflict pairs: ${conflictPairs.length}`);
console.log(`  Valid keys: ${validKeys.join(', ')}`);
console.log(`  Vague qualifiers: ${qualifiers.join(', ')}`);
console.log(`  Imperative verbs: ${imperativeVerbs ? imperativeVerbs.length : 'not found'}`);

// --- Generate playground script ---

function generateScript() {
  return `  <script>
  // AUTO-GENERATED by scripts/sync-playground.js — do not edit manually
  // Source: cursor-doctor/src/index.js
  // Last synced: ${new Date().toISOString().split('T')[0]}

  var VAGUE_PATTERNS = ${JSON.stringify(vaguePatterns, null, 4).replace(/\n/g, '\n  ')};

  var CONFLICT_PAIRS = ${JSON.stringify(conflictPairs, null, 4).replace(/\n/g, '\n  ')};

  var VALID_KEYS = ${JSON.stringify(validKeys)};

  var VAGUE_QUALIFIERS = ${JSON.stringify(qualifiers)};

  ${imperativeVerbs ? `var IMPERATIVE_VERBS = /\\\\b(${imperativeVerbs.join('|')})\\\\b/i;` : ''}

  function parseFrontmatter(content) {
    content = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');
    var match = content.match(/^---\\n([\\s\\S]*?)\\n---/);
    if (!match) return { found: false, data: null, error: null };
    try {
      var data = {};
      var lines = match[1].split('\\n');
      var currentKey = null, currentList = null;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line.match(/^\\s+-\\s+/)) {
          if (currentKey && currentList) {
            var val = line.replace(/^\\s+-\\s+/, '').trim();
            if (val.startsWith('"') && val.endsWith('"')) val = val.slice(1, -1);
            else if (val.startsWith("'") && val.endsWith("'")) val = val.slice(1, -1);
            currentList.push(val);
          }
          continue;
        }
        if (currentKey && currentList) { data[currentKey] = currentList; currentKey = null; currentList = null; }
        if (line.match(/^\\s+\\S/) && !line.match(/^\\s+-/)) {
          var prev = i > 0 ? lines[i-1] : null;
          if (prev && !prev.endsWith(':')) return { found: true, data: null, error: 'Invalid YAML indentation' };
        }
        var ci = line.indexOf(':');
        if (ci === -1) continue;
        var key = line.slice(0, ci).trim();
        var rv = line.slice(ci + 1).trim();
        if (rv === '') { currentKey = key; currentList = []; }
        else if (rv === 'true') data[key] = true;
        else if (rv === 'false') data[key] = false;
        else if (rv.startsWith('"') && rv.endsWith('"')) data[key] = rv.slice(1, -1);
        else data[key] = rv;
      }
      if (currentKey && currentList) data[currentKey] = currentList;
      return { found: true, data: data, error: null };
    } catch (e) { return { found: true, data: null, error: e.message }; }
  }

  function getBody(content) {
    var m = content.match(/^---\\n[\\s\\S]*?\\n---\\n?/);
    return m ? content.slice(m[0].length) : content;
  }

  function lint(content) {
    content = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');
    var issues = [];
    var fm = parseFrontmatter(content);
    var body = getBody(content);

    // --- Frontmatter checks ---
    if (!fm.found) {
      issues.push({ s:'error', m:'Missing YAML frontmatter', h:'Add --- block with description and alwaysApply fields' });
    } else if (fm.error) {
      issues.push({ s:'error', m:'YAML frontmatter error: '+fm.error, h:'Fix frontmatter indentation or syntax' });
    } else {
      var hasGlobs = fm.data.globs && (Array.isArray(fm.data.globs) ? fm.data.globs.length > 0 : fm.data.globs.trim().length > 0);

      if (fm.data.alwaysApply === undefined && !hasGlobs)
        issues.push({ s:'warning', m:'No alwaysApply or globs set', h:'Add alwaysApply: true for global rules, or add globs to scope to specific files' });

      var descEmpty = !fm.data.description || (typeof fm.data.description === 'string' && fm.data.description.trim() === '') || (Array.isArray(fm.data.description) && fm.data.description.length === 0);
      if (descEmpty)
        issues.push({ s:'warning', m:'Missing or empty description', h:'Add a description so Cursor knows when to apply this rule' });

      if (fm.data.alwaysApply === false && !hasGlobs)
        issues.push({ s:'error', m:'Rule will never load: alwaysApply is false and no globs set', h:'Set alwaysApply: true or add globs' });

      if (fm.data.description && typeof fm.data.description === 'string' && fm.data.description.trim().length > 0 && fm.data.description.trim().length < 10)
        issues.push({ s:'warning', m:'Description is very short (<10 chars)', h:'A longer description helps Cursor decide when to apply this rule' });

      if (fm.data.description && fm.data.description.length > 200)
        issues.push({ s:'warning', m:'Description is very long (>200 chars)', h:'Keep descriptions concise. Put details in the rule body.' });

      for (var key in fm.data) {
        if (VALID_KEYS.indexOf(key) === -1)
          issues.push({ s:'warning', m:'Unknown frontmatter key: '+key, h:'Valid keys: '+VALID_KEYS.join(', ') });
      }

      if (fm.data.description && /[*_\`#\\[\\]]/.test(fm.data.description))
        issues.push({ s:'warning', m:'Description contains markdown formatting', h:'Descriptions should be plain text. Save formatting for the rule body.' });

      if (fm.data.globs && typeof fm.data.globs === 'string' && fm.data.globs.indexOf(',') !== -1 && !fm.data.globs.trim().startsWith('['))
        issues.push({ s:'warning', m:'Globs as comma-separated string', h:'Use YAML array format for cleaner syntax' });

      if (fm.data.alwaysApply === true && hasGlobs)
        issues.push({ s:'info', m:'alwaysApply is true with globs set', h:"When alwaysApply is true, globs are a hint to the model but don't filter" });
    }

    // --- Body checks ---
    if (fm.found && body.trim().length === 0)
      issues.push({ s:'error', m:'Rule has frontmatter but no instructions', h:'Add rule instructions after the --- block' });

    if (body.length > 5000)
      issues.push({ s:'error', m:'Rule body exceeds 5000 chars (~1250 tokens)', h:'Split into multiple focused rules' });
    else if (body.length > 2000)
      issues.push({ s:'warning', m:'Rule body is very long (>2000 chars)', h:'Consider splitting into focused rules' });

    if (body.length > 200 && !/\`\`\`/.test(body) && !/\\n {4,}\\S/.test(body))
      issues.push({ s:'warning', m:'No code examples', h:'Rules with examples get followed more reliably' });

    // --- Vague rules (context-aware) ---
    var lines = content.split('\\n');
    for (var vi = 0; vi < lines.length; vi++) {
      var ll = lines[vi].toLowerCase().trim();
      if (ll.startsWith('#') || ll.startsWith('\`\`\`') || ll.length === 0) continue;
      for (var pi = 0; pi < VAGUE_PATTERNS.length; pi++) {
        var idx = ll.indexOf(VAGUE_PATTERNS[pi]);
        if (idx === -1) continue;
        var after = ll.slice(idx + VAGUE_PATTERNS[pi].length).trim();
        var qualified = false;
        for (var qi = 0; qi < VAGUE_QUALIFIERS.length; qi++) {
          if (after.startsWith(VAGUE_QUALIFIERS[qi] + ' ')) { qualified = true; break; }
        }
        if (qualified) continue;
        issues.push({ s:'warning', m:'Vague instruction: "'+VAGUE_PATTERNS[pi]+'"', h:'Be specific. What exactly should the AI do?', l:vi+1 });
        break;
      }
    }

    // --- Prompt engineering checks ---
    if (/\\b(try to|maybe|consider|perhaps|possibly|might want to)\\b/i.test(body))
      issues.push({ s:'warning', m:'Weak language detected (try to/maybe/consider)', h:'Use imperative mood: "Do X" instead of "try to do X"' });

    if (/\\b(please|thank you|thanks)\\b/i.test(body))
      issues.push({ s:'info', m:'Rule uses please/thank you', h:'Politeness wastes tokens. Be direct.' });

    if (/\\b(I want|I need|I\\'d like|my preference)\\b/i.test(body))
      issues.push({ s:'info', m:'Rule uses first person', h:'Use direct commands: "Use X" instead of "I want you to use X"' });

    if (body.length > 100 && !IMPERATIVE_VERBS.test(body))
      issues.push({ s:'warning', m:'No clear actionable instructions', h:'Use imperative verbs: use, write, create, ensure, etc.' });

    // --- Negations without alternatives ---
    var negationMatches = body.match(/\\b(don't|do not|never|avoid)\\s+(?:use|do|write)\\s+\\w+/gi);
    if (negationMatches && negationMatches.length > 0) {
      if (!/instead|rather|prefer|use \\w+ (?:rather|instead)/.test(body.toLowerCase()))
        issues.push({ s:'warning', m:'Rule uses negations without alternatives', h:"Instead of \\"don't use X\\", say \\"use Y instead of X\\"" });
    }

    // --- Self-conflict check ---
    var bl = body.toLowerCase();
    for (var ci = 0; ci < CONFLICT_PAIRS.length; ci++) {
      if (bl.indexOf(CONFLICT_PAIRS[ci].a) !== -1 && bl.indexOf(CONFLICT_PAIRS[ci].b) !== -1)
        issues.push({ s:'error', m:'Conflicting instructions about '+CONFLICT_PAIRS[ci].subject, h:'Choose one approach' });
    }

    // --- Structural checks ---
    if (/\\n\\n\\n\\n/.test(body))
      issues.push({ s:'info', m:'Excessive blank lines (>3 consecutive)', h:'Excessive whitespace wastes tokens' });

    if (/\\b(TODO|FIXME|HACK|XXX)\\b/.test(body))
      issues.push({ s:'warning', m:'Contains TODO/FIXME/HACK comments', h:'Unfinished rules confuse the model. Finish or remove.' });

    if (fm.data && fm.data.description && typeof fm.data.description === 'string' && fm.data.description.trim().length > 0 && body.trim().startsWith(fm.data.description))
      issues.push({ s:'warning', m:'Body starts with description repeated', h:'Redundant content wastes tokens' });

    // --- XML/HTML tags ---
    if (/<[^>]+>/.test(body) && !/\`\`\`/.test(body)) {
      var xmlTags = body.match(/<\\w+[^>]*>/g);
      if (xmlTags && xmlTags.length > 0)
        issues.push({ s:'warning', m:'Rule body contains XML/HTML tags', h:"Cursor doesn't process XML/HTML in rules. Use markdown or plain text." });
    }

    // --- Broken markdown links ---
    if (/\\]\\[/.test(body) || /\\[[^\\]]*\\]\\([^)]*$/.test(body))
      issues.push({ s:'warning', m:'Rule body has broken markdown links', h:'Fix link syntax: [text](url)' });

    // --- Inconsistent heading levels ---
    var headings = body.match(/^#{1,6}\\s+.+/gm);
    if (headings && headings.length >= 2) {
      var levels = headings.map(function(h) { return h.match(/^#+/)[0].length; });
      var hasSkip = false;
      for (var hi = 1; hi < levels.length; hi++) {
        if (levels[hi] > levels[0] + 1 && levels[hi - 1] < levels[hi] - 1) { hasSkip = true; break; }
      }
      if (hasSkip) issues.push({ s:'warning', m:'Inconsistent heading levels (jumps from # to ###)', h:'Use consistent heading hierarchy' });
    }

    // --- Body is just a URL ---
    var bodyTrimmed = body.trim();
    if (/^https?:\\/\\//.test(bodyTrimmed)) {
      var bodyLines = bodyTrimmed.split('\\n').filter(function(l) { return l.trim().length > 0; });
      var nonUrlLines = bodyLines.filter(function(l) { return !/^https?:\\/\\//.test(l.trim()); });
      if (nonUrlLines.length < 2)
        issues.push({ s:'warning', m:'Rule body appears to be just a URL', h:'Cursor cannot follow URLs. Put the actual instructions in the rule body.' });
    }

    // --- Mixed concerns ---
    var concernKeywords = {
      testing: /\\b(test|spec|jest|mocha|vitest|cypress|playwright)\\b/i,
      styling: /\\b(css|style|styled|tailwind|emotion|sass|less)\\b/i,
      naming: /\\b(naming|name|identifier|variable name|function name)\\b/i,
      types: /\\b(type|interface|generic|typescript|type safety)\\b/i,
      architecture: /\\b(architecture|structure|organization|folder|directory)\\b/i
    };
    var matchedConcerns = [];
    for (var ck in concernKeywords) {
      if (concernKeywords[ck].test(body)) matchedConcerns.push(ck);
    }
    if (matchedConcerns.length >= 3)
      issues.push({ s:'warning', m:'Rule mixes multiple concerns: '+matchedConcerns.join(', '), h:'Rules that cover too many topics are harder for the AI to apply. Split into focused rules.' });

    // --- Numbered lists where order doesn't matter ---
    var numberedLists = body.match(/\\n\\d+\\.\\s+/g);
    if (numberedLists && numberedLists.length >= 5) {
      if (!/\\b(first|second|third|then|next|finally|after|before)\\b/i.test(body))
        issues.push({ s:'info', m:'Numbered lists where order may not matter', h:'Bullet lists are more flexible when order is unimportant.' });
    }

    // --- Glob checks (playground-safe subset) ---
    if (fm.data && fm.data.globs) {
      var globs = [];
      if (typeof fm.data.globs === 'string') {
        var gt = fm.data.globs.trim();
        if (gt.startsWith('[')) globs = gt.slice(1,-1).split(',').map(function(g){return g.trim().replace(/^["']|["']$/g,'');}).filter(Boolean);
        else globs = gt.split(',').map(function(g){return g.trim().replace(/^["']|["']$/g,'');}).filter(Boolean);
      } else if (Array.isArray(fm.data.globs)) globs = fm.data.globs;

      for (var gi = 0; gi < globs.length; gi++) {
        var glob = globs[gi];
        if (glob === '*' || glob === '**')
          issues.push({ s:'warning', m:'Overly broad glob pattern', h:'This matches everything. Use more specific patterns or alwaysApply: true.' });
        if (glob.indexOf('\\\\') !== -1)
          issues.push({ s:'warning', m:'Glob uses Windows backslashes: '+glob, h:'Use forward slashes for cross-platform compatibility.' });
        if (glob.endsWith('/'))
          issues.push({ s:'warning', m:'Glob has trailing slash: '+glob, h:'Trailing slashes are not valid glob syntax.' });
        if (glob.startsWith('./'))
          issues.push({ s:'info', m:'Glob starts with ./: '+glob, h:'Cursor resolves from project root. The ./ prefix is unnecessary.' });
        if (glob === '*.')
          issues.push({ s:'warning', m:'Glob has no file extension after dot', h:'Add an extension: *.ts, *.js, etc.' });
        if (glob.indexOf(' ') !== -1)
          issues.push({ s:'warning', m:'Glob pattern contains spaces', h:'Glob patterns with spaces may not match correctly.' });
      }
    }

    return issues;
  }

  function render(issues) {
    var el = document.getElementById('results');
    var sum = document.getElementById('summary');
    var cnt = document.getElementById('result-count');

    if (issues.length === 0) {
      el.innerHTML = '<div class="result-item result-ok"><span class="result-severity">pass</span> No issues found. This rule looks good.</div>';
      sum.style.display = 'flex';
      sum.innerHTML = '<span class="clean count">\\u2713 Clean</span>';
      cnt.textContent = '0 issues';
      return;
    }

    var errors = 0, warnings = 0, infos = 0;
    var html = '';
    for (var i = 0; i < issues.length; i++) {
      var iss = issues[i];
      var cls = iss.s === 'error' ? 'result-error' : iss.s === 'warning' ? 'result-warning' : 'result-info';
      if (iss.s === 'error') errors++;
      else if (iss.s === 'warning') warnings++;
      else infos++;
      html += '<div class="result-item '+cls+'">';
      html += '<span class="result-severity">'+iss.s+'</span>';
      if (iss.l) html += '<span class="result-line">Line '+iss.l+': </span>';
      html += iss.m;
      if (iss.h) html += '<div class="result-hint">'+iss.h+'</div>';
      html += '</div>';
    }
    el.innerHTML = html;
    cnt.textContent = issues.length + ' issue' + (issues.length === 1 ? '' : 's');

    var parts = [];
    if (errors) parts.push('<span class="errors count">'+errors+' error'+(errors===1?'':'s')+'</span>');
    if (warnings) parts.push('<span class="warnings count">'+warnings+' warning'+(warnings===1?'':'s')+'</span>');
    if (infos) parts.push('<span class="count">'+infos+' info</span>');
    sum.style.display = 'flex';
    sum.innerHTML = parts.join('');
  }

  var EXAMPLES = {
    broken: '---\\ndescription\\nalwaysApply true\\n---\\nUse TypeScript strict mode.',
    vague: '---\\ndescription: General coding rules\\nalwaysApply: true\\n---\\nWrite clean code.\\nFollow best practices.\\nBe consistent.\\nHandle errors properly.',
    conflict: '---\\ndescription: Style rules\\nalwaysApply: true\\n---\\nAlways use semicolons at the end of every statement.\\n\\nAvoid semicolons. No semicolons in this project.',
    good: '---\\ndescription: TypeScript error handling in API routes\\nglobs:\\n  - "src/api/**/*.ts"\\n  - "src/routes/**/*.ts"\\n---\\nWrap all route handlers in try-catch blocks.\\n\\nReturn structured error responses:\\n\\n\`\`\`typescript\\ncatch (error) {\\n  return Response.json(\\n    { error: error.message, code: "INTERNAL_ERROR" },\\n    { status: 500 }\\n  );\\n}\\n\`\`\`\\n\\nNever expose stack traces in production responses.\\nLog the full error with \`console.error(error)\` before returning.',
    dead: '---\\ndescription: Python formatting\\nalwaysApply: false\\n---\\nUse black for formatting.\\nLine length 88 characters.',
    bloated: '---\\ndescription: Everything about our codebase\\nalwaysApply: true\\n---\\n' + Array(201).join('This rule covers everything.\\n') + '\\nPlease try to maybe follow these guidelines.\\nI want you to be careful.\\nTODO: finish this rule later.'
  };

  function loadExample(name) {
    document.getElementById('editor').value = EXAMPLES[name];
    run();
  }

  function run() {
    var content = document.getElementById('editor').value;
    if (!content.trim()) {
      document.getElementById('results').innerHTML = '<div class="result-item result-info"><span class="result-severity">tip</span> Paste a rule on the left to see diagnostics here.</div>';
      document.getElementById('summary').style.display = 'none';
      document.getElementById('result-count').textContent = '';
      return;
    }
    render(lint(content));
  }

  document.getElementById('editor').addEventListener('input', run);

  function copyCommand(btn) {
    var cmd = btn.getAttribute('data-cmd');
    navigator.clipboard.writeText(cmd).then(function() {
      btn.classList.add('copied');
      setTimeout(function() { btn.classList.remove('copied'); }, 1500);
    });
  }
  </script>`;
}

// --- Replace script in playground.html ---

const html = fs.readFileSync(PLAYGROUND, 'utf-8');
const scriptStart = html.indexOf('  <script>');
const scriptEnd = html.indexOf('  </script>') + '  </script>'.length;

if (scriptStart === -1 || scriptEnd === -1) {
  console.error('ERROR: Could not find <script> block in playground.html');
  process.exit(1);
}

const newHtml = html.slice(0, scriptStart) + generateScript() + html.slice(scriptEnd);
fs.writeFileSync(PLAYGROUND, newHtml, 'utf-8');

console.log('\n✓ playground.html updated successfully');
console.log(`  Checks synced: vague patterns, conflict pairs, valid keys, prompt engineering, structural, glob checks`);
